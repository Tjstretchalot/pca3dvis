"""The state for the act that corresponds to the videos that are generated by
this package.
"""
import typing
import numpy as np
import pytypeutils as tus

from pca3dvis.snapshot import ProjectedSnapshot
from pca3dvis.trajectory import ProjectedTrajectory

import pympanim.acts as acts

def get_square_bounds(zoom: np.ndarray) -> np.ndarray:
    """Converts the potentially rectangular zoom to a square zoom

    Arguments:
        zoom (ndarray[3, 2]): the current possible rectangular zoom
            for each axis

    Returns:
        ndarray[3, 2]: the smallest bounding cube for the zoom
    """
    diffs = zoom[:, 1] - zoom[:, 0]
    biggest_diff = diffs.max()
    cents = zoom.mean(1)

    mins = cents - biggest_diff/2
    maxs = cents + biggest_diff/2
    return np.concatenate((mins.reshape(3, 1), maxs.reshape(3, 1)), 1)

def get_square_bounds_for(points: np.ndarray) -> np.ndarray:
    """Gets the smallest cube that completely contains the given points.

    Args:
        points (np.ndarray[samples, 3]): the samples to bound

    Returns:
        zoom (np.ndarray[3, 2]): the min/max for each axis respectively
    """
    zoom = np.concatenate(
        (points.min(0).reshape(3, 1), points.max(0).reshape(3, 1)), 1
    )
    return get_square_bounds(zoom)

def get_square_bounds_for_all(
        points: typing.Iterable[np.ndarray]) -> np.ndarray:
    """Gets smallest cube that completely contains all of the given
    points
    Args:
        points (iterable[np.ndarray[samples, 3]]): the samples to bound

    Returns:
        zoom (np.ndarray[3, 2]): the min/max for each axis respectively
    """
    zoom = np.zeros((3, 2), 'float32')
    for i, pts in enumerate(points):
        if i == 0:
            zoom[:, 0] = pts.min(0)
            zoom[:, 1] = pts.max(0)
        else:
            zoom[:, 0] = np.min((zoom[:, 0], pts.min(0)), 0)
            zoom[:, 1] = np.max((zoom[:, 1], pts.max(0)), 0)
    return get_square_bounds(zoom)

class ProjectedState(acts.ActState):
    """Describes the state that can be rendered to produce a single pc
    trajectory

    Attributes:
        trajectory (ProjectedTrajectory):
            the overall trajectory that this is trying to plot
        default_styling: (tuple[tuple[ndarray, dict]]): the default styling for
            each sample. in each element, the first element is the mask (i.e. a
            bool array with shape (trajectory.num_samples,)) and the second
            element contains the keyword arguments to scatter
        title (str): the title of the plot
        zoom (np.ndarray[3, 2]):
            each element corresponds to the min and max for a single axes
        rotation (tuple[float, float]): the elevation and azimuth angle
        visible_points (tuple[tuple[np.ndarray[samples, 3], ndarray, dict]]):
            each element should contain:
                the points that should be scattered
                a mask (bool array) that states which sample points the points
                belong to
                an dict of keyword arguments which override the default styling
                for those points. dict() for default styling, {'c': '#ccccc'}
                for default styling except all gray, etc.
    """
    def __init__(
            self,
            trajectory: ProjectedTrajectory,
            default_styling: typing.Tuple[typing.Tuple[np.ndarray, dict]],
            title: str = 'Projected Trajectory',
            zoom: np.ndarray = None,
            rotation: typing.Tuple[float, float] = (30, 45),
            visible_points: typing.Tuple[
                typing.Tuple[np.ndarray, np.ndarray, dict]] = None):
        if visible_points is None:
            visible_points = ((
                trajectory.snapshots[0].projected_samples,
                np.ones(trajectory.num_samples, dtype='bool'),
                dict()
            ),)
        if zoom is None:
            zoom = get_square_bounds_for_all(pts for (pts, mask, d) in visible_points)

        tus.check(
            trajectory=(trajectory, ProjectedTrajectory),
            default_styling=(default_styling, (list, tuple)),
            title=(title, str),
            rotation=(rotation, (list, tuple)),
            visible_points=(visible_points, (list, tuple))
        )
        tus.check_ndarrays(zoom=(zoom, (3, 2), ('float32', 'float64')))
        tus.check_listlike(rotation=(rotation, (int, float), 2))

        self.trajectory = trajectory
        self.default_styling = default_styling
        self.title = title
        self.zoom = zoom
        self.rotation = rotation
        self.visible_points = visible_points

    def set_snapshot_visible(self, snapshot_ind: int,
                             update_zoom: bool = False):
        """Modifies the states visible points to reflect the given snapshot.
        May optionally update the zoom to match the snapshot.

        Arguments:
            snapshot_ind (int): the index in trajectories.snapshots for the
                snapshots whose projected_samples should be the visible
                points, with all default styling
            update_zoom (bool, default False): if True, the zoom for this state
                is updated to be the smallest cube that contains all the points
        """
        snap: ProjectedSnapshot = self.trajectory.snapshots[snapshot_ind]

        self.visible_points = ((
            snap.projected_samples, np.ones(snap.num_samples, dtype='bool'),
            dict()),)

        if update_zoom:
            self.zoom = get_square_bounds_for(snap.projected_samples)
